# 11. 코루틴과 동시성 프로그래밍

# 11-1 동시성 프로그래밍

- 비동기적 : 여러 개의 루틴이 선행 작업의 순서나 완료 여부와 상관 없이 실행되는 방식

     → 비동기적 프로그래밍은 RxJava, Reactive와 같은 서드파티 라이브러리에서 제공

     → 코틀린에서는 코루틴을 기본으로 제공

- 스레드와 같은 비동기 코드를 작성하여 다중 작업을 처리하는데, 이 때 코드가 복잡해진다.

     → 코틀린의 코루틴을 사용하여 동기 코드처럼 쉽게 작성하면서도 비동기 효과를 낼 수 있다.

## 블로킹과 넌블로킹

### **블로킹**

입출력 과정 등이 수행될 때 high 태스크의 작업이 일시정지되는 방법

(운영체제의 스케줄링 정책에 따라 우선순위가 낮은 다른 태스크가 실행될 수 있음)

### **넌블로킹**

입출력 요청을 하더라도 운영체제에 의해 실행 중이던 태스크가 EAGAIN과 같은 시그널을 받아 실행을 재개하는 방법

## 프로세스와 스레드

### **프로세스**

- 프로그램이 실행되면 프로세스 시작
- 실행되는 메모리, 스택, 열린 파일 등을 모두 포함
- 프로세스 간에는 완전 독립되어 있기 때문에 문맥 교환에 비용이 많이 듬

### 스레드

- 레지스터와 스택만 독립적으로 가지고 대부분의 문맥은 프로세스 안에서 공유
- 문맥 교환 비용이 낮음
- 여러개의 스레드를 구성하면 코드가 복잡

(하나의 프로세스에서 1개 이상의 스레드를 가지고 있다고 생각하면 될 듯)

코틀린에서 전통적인 스레드 개념을 만들지 않고 좀더 쉽게 비동기 프로그래밍을 할 수 있는 방법
→ 코루틴!
→ 문맥 교환이 없고 최적화된 비동기 함수를 통해 비선점형으로 작동 
→ 협력형 멀티태스킹 구현

**기존 자바 방식으로 스레드 생성하는 방법**

- Thread 클래스 상속
- Runnable 인터페이스 구현

⇒ 해당 클래스 객체의 start() 메서드 호출을 통해 run() 본문 수행

**스레드 풀 사용하기**

- newFixtedThreadPool()로 스레드를 인자의 수만큼 만들고 작업을 수행 할 때 이 풀 안의 스레드를 사용하도록 함

# 11-2 코루틴의 개념과 사용 방법

## 코루틴의 장점

- 스레드를 이용하는 넌블로킹 코드는 성능이 뛰어나지만 코드가 복잡하여 안전성이 떨어짐

    → 코루틴을 이용하여 코드의 복잡성을 줄이자!

- 프로세스나 스레드는 해당 작업을 중단하고 다른 루틴을 실행하기 위한 문맥 교환을 시도할 때 많은 비용이 듬

    → 코루틴은 비용이 많이 드는 문맥 교환 없이 해당 루틴을 일시 중단해서 이러한 비용을 줄일 수 있다!

    → 일시 중단은 사용자가 제어할 수 있다!

## 코루틴의 주요 기능

- 코루틴 빌더의 생성은 launch, async
- 코루틴 기능을 사용하기 위해서는 suspend()로 선언어야 함

    → suspend() 함수는 또다른 지연 함수 내에서 사용하거나 코루틴에서만 사용가능!

- 코루틴을 실행시키기 위해서는 내부적으로 스레드를 통해서 실행

    → 실행 루틴이 많지 않은 경우에는 내부적으로 하나의 스레드에서 여러 개의 코루틴 실행 가능

    → 1개의 스레드로도 충분

### launch

- 현재 스레드를 차단하지 않고 새로운 코루틴 실행
- Job객체 반환
- Scope를 통해 실행 범위 결정

### async

- 새로운 코루틴 실행
- 복잡한 루틴을 작성하는 경우에는 많은 태스크들과 병행 수행되므로 어떤 루틴이 먼저 종료될지 알기 힘듬

    → 태스크가 종료되는 시점을 기다렸다가 결과를 받을 수 있도록 await() 사용

- Deferred<T>를 통해 결괏값 반환

### 코루틴의 문맥

- launch { ... }와 같이 인자가 없는 경우에는 CoroutineScope에서 상위 문맥이 상속되어 결정
- launch(Dispatchers.Default) { ... }와 같이 사용되면 GlobalScope에서 실행되는 문맥과 동일하게 사용 (GlobalScope는 메인 스레드의 생명주기가 끝나면 같이 종료)
- 내부적으로 코루틴이 사용할 스레드의 공동 풀을 사용

**코루틴에 실행 스레드 개수를 직접 지정하려면?**
val threadPoop = Executors.newFixedThreadPool(4)
val myContext = threadPoop.asCoroutineDispatcher()
async(myContext) { ... }

### 시작 시점에 대한 속성 (CoroutineStart)

- DEFAULT : 즉시 시작
- LAZY : 코루틴을 느리게 시작 (처음에는 중단된 상태이며 start()나 await() 등으로 시작됨)
- ATOMIC : 최적화된 방법으로 시작
- UNDISPATCHED : 분산 처리 방법으로 시작

### **runBlocking의 사용**

- 새로운 코루틴을 실행하고 완료되기 전까지 현재 스레드를 블로킹

### **join()의 함수의 결과 기다리기**

- 명시적으로 코루틴의 작업이 완료되는 것을 기다리게 함

### 많은 작업의 처리

- jobs.forEach { it.join() }
- repeat

## 코루틴과 시퀀스

- sequenc()를 사용하여 많은 값을 만들어내는 코드로 부터 특정 범위의 값을 가져올 수 있음
- yield() : 잠시 실행을 멈추고 요소를 반환(산출) 후 멈춘 시점에서 다시 실행하는 코루틴 생성

    → 모든 요소는 일회성이기 때문에 다음 요소를 직접 지정하려면 iterator()를 통해 next() 메서드 사용

# 11-3 코루틴 동작 제어하기

## 코루틴의 문맥

- 코루틴을 어떤 문맥에서 실행할 지는 Dispatcher가 결정
- Dispatchers.Default = GlobalScope : 공유된 백그라운드 스레드의 CommonPool에서 실행

    → 기존 스레드 사용

    → 연산 중심 코드에 적합

- [Dispatchers.IO](http://dispatchers.IO) : 입출력 위주의 동작을 하는 코드에 적합한 공유 풀

    → 블로킹 동작이 많은 파일이나 소켓 I/O 처리에 적합

- Dispatchers.Unconfined : 호출자 스레드에서 코루틴을 시작하지만 첫번째 지연점까지만 실행

    → 사용할 것을 권장하지 않음

- coroutineContext : 부모의 문맥
- newSingleThreadContext : 새 스래드 생성

    → 비용이 많이 들고 더 이상 필요하지 않으면 해제하거나 종료시켜야 함

코루틴 안에 또 다른 코루틴을 정의하면 자식 코루틴의 되는데, 부모가 취소되는 경우 자식 코루틴은 재귀적으로 취소됨 → 필요한 경우 join() 함수를 사용해 명시적으로 처리를 기다리도록 만들어야 함

## 기본 동작 제어하기

- try ~ finally 의 finally 블록에서 지연 함수를 사용하려고 하면 코루틴이 취소되므로 사용 불가
- finally 블록에서 시간이 걸리는 작업이나 지연 함수가 사용될 경우 실행을 보장하기 위하여 NonCancellable 문맥에서 작동하도록 해야함

    → withContext(NonCancellable) { ... } 사용

### 코루틴의 시간만료

- withTimeout() : 일정 실행 시간 뒤에 코루틴 취소, 취소시킨 뒤 TimeoutCancellationException 발생
- withTimeoutOrNull() : 예외를 발생시키지 않고 null 처리

## 채널의 동작

- 자료를 서로 주고받기 위한 통로 역할
- 넌 블로킹 전송 개념
- SendChannel / ReceiveChannel 인터페이스 이용 (send() / receive())

주의!!
- 송신자는 SendChannel에서 isFull값이 true이면 일시 지연
    → close로 닫으면 isFull값이 false를 반환할 수도 있음
- 수진자는 ReceiveChannel에서 isEmpty가 true이면 일시 지연
    → close로 닫으면 isEmpty가 false를 반환할 수도 있음

## produce 생산자 소비자 패턴

- produce : 채널이 붙어 있는 코루틴
- 채널에 값을 보내어 생산자 역할을 하기도 하고 consumeEach 함수를 확장해 소비자 역할을 하기도 한다.

### 버퍼를 가진 채널

- 채널에는 기본 버퍼가 없음
- send() 함수가 먼저 호출되면 receive() 함수가 호출되기 전까지 send() 함수는 일시 지연
- receive() 함수가 먼저 호출되면 send() 함수가 호출되기 전까지 receive() 함수는 일시 지연

    → 버퍼 크기를 주면 지연 없이 여러 개의 요소 보낼 수 있음

### select 표현식

- onReceive를 통해 채널로부터 이 값을 받아 먼저 완성된 결과를 가져옴

# 11-4 공유 데이터 문제 알아보기

### 공유 자원의 무결성을 보장할 수 있는 방법

- Java : synchronized
- 코틀린 : synchronized + 원자 변수, 스레드 가두기, 상호 배제

    → 공유자원의 보호와 스레드 안전 구현

## 동기화 기법

### synchronized 메서드와 블록

- 특정 스레드가 이미 자원을 사용하는 중이면 나머지 스레드의 접근을 막는다
- 코틀린에서는 @Synchronized 애노테이션 표기법 사용

### 자바의 volatile

- 데이터를 캐시에 넣지 않도록 함
- 코드가 최적화되면서 순서가 바뀌는 경우 방지
- 두 스레드에서 공유 변수에 대한 읽기와 쓰기 연산이 있으면 volatile만으로는 충분하지 않음

### 원자 변수

- Atomic자료형 (ex AtomicInteger)
- 특정 변수의 증가나 감소, 더하기나 빼기가 단일 기계어 명령(CPU가 명령을 처리하는 최소 단위)으로 수행

    → 해당 연산이 수행되는 도중에는 누구도 방해 못함

    → 값의 무결성 보장

### 스레드 가두기

- 특정 문맥에서 작동하도록 단일 스레드에 가두는 방법
- newSingleThreadContext 사용
- 이 방법은 시간이 많이 걸린다!

### 상호 배제

- 코드가 임계 구역에 있는 경우 절대로 동시성이 일어나지 않게 함
- 자바의 synchronized 키워드와 비슷한 개념
- 코루틴에서는 Mutex의 lock과 unlock 사용
- 다른 루틴에서 이미 lock에 걸린 임계구역에 접근하기 위해 lock()을 호출하면 일시 중단
- 다른 루틴에서 이미 lock에 걸린 임계구역에 접근하기 위해 tryLock()을 호출하면 false 반환 후 빠져나옴
- holdLock()을 사용하여 해당 임계구역의 소유자인지 확인 가능
- Mutex().withLock { ... } 으로도 사용 가능

## actor 코루틴 빌더

- 코루틴과 채널에서 통신하거나 상태 관리
- 들어오는 메일 박스 기능만 함
- 한 번에 1개의 메시지만 처리하는 것을 보장

    → 어떤 특정 상태를 관리하기 위한 백그라운드 태스크에 유용

## 이벤트 루프

- 항상 이벤트를 기다리며 감시하는 주체가 있음
- 이벤트가 발생하면 이것을 처리하기 위해 특정 루틴 동작
