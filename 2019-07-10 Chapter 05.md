# 05. 클래스와 객체

# 05-1 클래스와 객체의 정의

## **코틀린에서 사용하는 용어**

클래스, 프로퍼티, 메서드, 객체

## 클래스 생성 및 활용

1. 클래스 추상화 (공통 프로퍼티 및 메서드 묶기)
2. 클래스 선언
3. 클래스를 활용한 인스턴스 생성

# 05-2 생성자

- 객체를 생성할 때 항상 같은 프로퍼티를 갖게 하기 위해 사용
- 외부에서 인자를 받아 초기화 하기 위해서는 constructor() 사용

## constructor 분류

- 주 생성자 : 클래스 이름 옆에 정의
    - 기본적으로는 constructor 생략 가능
    - 가시성 지시자나 어노테이션 표기가 클래스 선언에 있다면 생략 불가
    - var나 val를 constructor 안에서 이용하면 프로퍼티 선언도 생략 가능
    - 초기화에 꼭 사용해야할 코드가 있다면 init 블록에서 선언해야함
    - 기본값이 있는 인자는 객체를 생성할 때 생략 가능
- 부 생성자 : 클래스 내부에 함수처럼 정의
    - constructor() {} 블록에서 초기화 코드 사용가능
- 추가 부 생성자 : 부 생성자는 매개변수를 달리하여 여러개 정의할 수 있음 (일종의 오버로딩)

참고 (this)
- 함수 내부에서 프로퍼티에 접근하려면 this 사용 (자바와 동일)
- 함수의 파라메터와 프로퍼티의 이름이 같으면 this를 사용해야함
- this를 사용하지 않으려면 매개변수 이름을 프로퍼티 이름과 다르게 하면 되는데 보통 매개변수 이름 앞에 _를 붙임

# 05-3 상속과 다형성

- 기존 클래스를 기반으로 새로운 프로퍼티나 메서드를 정의하여 생성
- 모든 클래스는 Any 클래스의 하위 클래스
- 상속할 수 있는 클래스로 만들려면 open 키워드 사용

코틀린은 기본 클래스가 상속할 수 없는 클래스
자바는 기본 클래스가 상속할 수 있는 클래스
- 자바에서 상속할 수 없는 클래스로 만들려면 final 키워드 사용해야함

- 클래스 상속은 변수 선언과 같이 : 사용

변수 선언은 변수 뒤에 :의 공백이 없이 쓰지만 클래스 상속은 관례적으로 변수 선언과 구분하기 위하여 공백을 붙인다.

## 다형성

### 오버로딩

- 동일한 클래스 안에 매개변수를 달리하면 같은 이름을 가진 메서드를 정의 할 수 있다는 개념

### 오버라이딩

- 상위 클래스의 메서드를 하위 클래스에서 재정의 할 수 있다는 개념
- 상위 클래스와 재정의할 메서드에는 open, 하위 클래스의 재정이 메서드에는 override 키워드 사용
- 오버라이딩된 메서드 앞에 final 키워드를 사용하면 하위 클래스에서 재정의 되는 것을 막을 수 있음

# 05-4 super와 this의 참조

- super : 상위 클래스의 프로퍼티, 메서드, 생성자 참조
- this : 현재 클래스의 프로퍼티, 메서드, 생성자 참조
- 상속을 통해서 클래스를 만드는 경우, 상위 클래스의 생성자가 있다면 반드시 하위 클래스에서 호출해야 함

this로 주생성자를 호출하는 부생성자 호출 순서 (P.227)
부생성자 호츨 → this에 의한 주생성자 호출 → 프로퍼티 할당 → 초기화 블록 → 부생성자 본문

- 이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면 super@바깥 클래스 이름
- 상위 클래스의 메서드와 구현받는 인터페이스의 메서드 명이 같을 경우

    → 반드시 둘 중 하나의 메서드를 오버라이드 해야함

    → 호출 할 때에는 super<클래스/인터페이스 이름>.메서드() 로 구분

자바에서는 불가능하지만 코틀린에서는 인터페이스에서 메소드의 구현을 할 수 있다.
구현이 되어있으면 인터페이스를 상속받는 클래스에서 재구현은 선택이지만, 구현되어있지 않으면 반드시 구현을 해야한다. 

# 05-5 정보 은닉 캡슐화

** 괄호는 UML에서의 기호

### public (+)

- 어디서든 접근 가능 (기본값)

### private (-)

- 외부 접근 불가
- private 클래스를 같은 파일에 있는 다른 클래스에서 프로퍼티로 생성할 때에는 똑같이 private 지정해야 함
- private 프로퍼티 및 메서드는 해당 클래스가 아니면 어디에서도 접근 불가

### protected (#)

- 외부 접근 불가, 하위 상속 요소에서 접근 가능
- 최상위 요소에는 지정 불가

### internal (없음)

- 같은 모듈에서만 접근 가능 (자바에서는 없음)

자바의 package(~) 지시자
- 한 패키지 내부에서 접근 가능
- 단점 : 프로젝트 단위 묶음의 .jar 파일이 달라져도 패키지 이름이 동일하면 다른 .jar에서도 접근 가능 ⇒ 보안이슈
⇒ 코틀린에서는 같은 모듈에서만 접근할 수 있게 하는 internal 지시자로 대체하고 package는 사용하지 않음

# 05-6 클래스와 클래스의 관계

### 연관

- 2개의 서로 분리된 클래스의 연결
- 단방향 / 양방향
- 두 요소가 서로 다른 생명주기 (각각의 생명주기에 영향을 미치지 않음)

### 의존

- 한 클래스가 다른 클래스에 의존되어 영향을 주는 경우
- 영향을 주는 클래스가 있어야만 영향을 받는 클래스를 생성 가능

### 집합

- 특정 객체를 소유
- 객체가 따로 생성되어 생명주기에 영향을 미치지는 않음

### 구성

- 특정 클래스가 어느 한 클래스의 부분이 됨
- 부분이 되는 클래스는 소유자 클래스의 생명주기에 의존

— 끝! —
