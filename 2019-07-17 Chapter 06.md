# 06. 프로퍼티와 초기화

프로퍼티란 변수와 접근 메서드가 포함된 개념.

프로퍼티는 게터와 세터가 자동으로 만들어 집니다.

프로퍼티는 반드시 **초기화** 되어야 하고, 즉시 초기화 하지 못한 경우  `lateinit`과 `lazy`를 사용하는 기법이 있음.

# 프로퍼티의 접근

**프로퍼티** : 클래스 내에 선언한 변수 / java에서는 **필드**라고 함.

## 자바에서 필드를 사용할 때의 문제점

클래스를 생성 한 후 필드를 할당하고 private로 지정한다면 값을 할당하거나 읽기 위해 접근 메서드(게터와 세터)를 만들어 주어야 합니다.

결국 자바의 필드가 늘어나면 접근 메서드의 양도 많아져 코드가 읽기 어렵게 됩니다.

**※ Java의 코드**

    public class Person {
        private String name;
        private int age;
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    }

**※ Kotlin의 코드**

    class Person(var name: String, var age:Int)

## 코틀린에서 게터와 세터가 작동하는 방식

Kotlin에서는 다음과 같이 할당이 됩니다.

    // 주 생성자에 3개의 매개변수
    class User(_id: Int, _name: String, _age: Int){
    	// 프로퍼티
    	val id = _id // val, 불변 읽기전용
    	var name = _name // var, 변경 가능
    	var age = _age
    }

위의 표현을 다음과 같이 간소화 할 수 있습니다.

    class User(val id: Int, var name: String, var age: Int)

### 게터와 세터의 동작 확인

    fun main(){
    	val user = User(1, "Sean", 30)
    	
    	val name = user.name // 프로퍼티에 직접 접근하는것 처럼 보이지만 게터가 동작
    	
    	user.age = 41  // 프로퍼티에 직접 할당하는것 처럼 보이지만 세터가 동작
    
    	user.id = 2 // 오류 : val 프로퍼티는 게터만 동작함!
    
    	println("name: $name, ${user.age}")
    }

**※ 실제 디컴파일 코드**

`val`과 `var`에서 실제 생성된 게터 세터의 차이를 봅시다.

    public final class User {
       private final int id;
       @NotNull
       private String name;
       private int age;
    
       public final int getId() {
          return this.id;
       }
    
       @NotNull
       public final String getName() {
          return this.name;
       }
    
       public final void setName(@NotNull String var1) {
          Intrinsics.checkParameterIsNotNull(var1, "<set-?>");
          this.name = var1;
       }
    
       public final int getAge() {
          return this.age;
       }
    
       public final void setAge(int var1) {
          this.age = var1;
       }
    
       public User(int id, @NotNull String name, int age) {
          Intrinsics.checkParameterIsNotNull(name, "name");
          super();
          this.id = id;
          this.name = name;
          this.age = age;
       }
    }

## 기본 게터와 세터 직접 지정하기

**※ 프로퍼티 선언 구조**

    var 프로퍼티 이름[: 프로퍼티 자료형] [= 프로퍼티 초기화]
    	[get() { 게터 본문 } ]
    	[set() { 세터 본문 } ]
    
    // val은 게터만 가능.
    val 프로퍼티 이름[: 프로퍼티 자료형] [= 프로퍼티 초기화]
    	[get() { 게터 본문 } ]

**※ 실제 구현**

    class Person(_name: String, _age: Int) {
    
        val name = _name
            get() = field // 기본 게터과 동일한 경우 지우라는 워닝 나타남
    
    
        var age = _age
            get() = field
            set(value) {
                field = value
            }
    
    		//!! 주의 
    		// get() = name과 같이 하면 name의 get을 다시 호출하므로 무한 재귀호출에 빠진다.
    		// 다행히 컴파일러에서 에러 잡아줌!
    		// set도 동일
    		// 이와 같은 상황을 위해 보조필드를(value와 field) 사용한다.
    }

`value`: 세터의 **매개변수**로 외부로부터 값을 가져옴

`field`: 프로퍼티를 참조하는 변수

※ `field`는 이름을 변경할 수 없고, 세터의 `value`는 이름을 변경하여 사용할 수 있다.

## 커스텀 게터와 세터의 사용

1. 입력 문자를 대문자로 바꾸어 저장하는 등 연산이 필요한 경우 게터와 세터를 확장하여 구성

    class Person2(_name: String, _age: Int) {
    
        var name = _name
            set(value){
                field = value.toUpperCase()
            }
    
        var age = _age
    }

2. 내부에서만 세터를 사용할 수 있도록 접근제어자 사용

    var name = _name
    	private set(value){
    	    field = value.toUpperCase()
    	}

3. 보조 프로퍼티 사용 

보조 필드를 사용하지 않고 다른 임시 프로퍼티를 할당하고 대신 제공할 수 있다. 

    class Person(_name: String, _age: Int) {
    		private var tmpName: String? = null
        var name = _name
            get(){
    					if(tmpName == null) tmpName = "NONAME"
    					return tmpName ?: throw AssertionError("Asserted by others")
    				}
        var age = _age
    }

4. 프로퍼티의 오버라이딩

프로퍼티는 기본적으로 오버라이딩 불가능한 final 형태이지만 `open` 키워드를 사용하여 가능하게 할 수 있다.

이를 이용하여 게터를 구현할 수 있다.

    open class First {
        open val x: Int = 0
            get() {
                println("First $field")
                return field
            }
    }
    
    class Second : First() {
        override val x: Int = 0
            get() {
                println("Second $field")
                return field + 3
            }
    }

※ 오버라이딩 시 val로 정의된 프로퍼티는 var로 변경 할 수 있다.

※ var은 val로 바꿀 수 없다.

?? super를 호출 할 수 있을까??

# 지연 초기화와 위임

프로퍼티의 자료형들은 not null이 기본이기 때문에 생성자나 매개변수로부터 초기화 하는것이 규칙

객체 생성과 동시에 프로퍼티를 초기화 할 수 없는 경우 초기화 지연이 필요함.

`lateinit`과 `lazy` 키워드에 대해 공부해 볼 것

## lateinit을 사용한 지연 초기화

**사용 예**

- 클래스 의존성이 있을 때

- 해당 프로퍼티를 즉시 사용하지 않는데 미리 초기화 하는 경우 메모리 낭비

- 유닛 테스트를 할 때 임시적으로 객체를 생성시키는 경우

### 프로퍼티, 객체 지연 초기화 하기

프로퍼티는 null을 허용하지 않기 때문에 바로 할당하지 않으면 컴파일러 에러가 발생

`lateinit` 키워드를 이용하면 컴파일러에서 허용됨

단, 실행시까지 초기화 되지 않으면 에러가 발생하니 주의!

※ `lateinit`의 제한사항

1. var로 선언된 프로퍼티만 가능
2. 프로퍼티는 커스텀 게터와 세터를 사용할 수 없다.

    `'lateinit' modifier is not allowed on properties with a custom getter or setter`

    lateinit var person: Person // 객체의 지연 초기화
    
    fun main() {
        person = Person() // 객체 초기화
        person.test()
        person.name = "cov" // 프로퍼티 초기화
        person.test()
    }
    
    class Person{
        lateinit var name: String // 프로퍼티의 지연 초기화
    
        fun test(){
            if(::name.isInitialized){
                println("initialized")
            }else{
                println("not initialized")
            }
        }
    }

※ `::`를 이용하여 대상의 참조를 하여, `isInitialized` 상태를 체크할 수 있음.

## lazy를 사용한 지연 초기화

lateinit에서 var로 선언해야 한다는 조건이 값이 언제든 변경될 수 있다는 단점이 있습니다.

val의 초기화 지연을 하기 위해서는 `lazy` 키워드를 사용합니다.

※ lazy의 특징

1. 호출 시점에 `by lazy{...}` 정의에 의해 블록 부분의 초기화를 진행한다.
2. val에서만 사용 가능하다.

### 프로퍼티 지연 초기화

최초 접근 시점에 lazy 블록이 실행되어 초기화 합니다.

그 이후 접근하는 경우 초기화 된 값을 사용합니다.

    class LazyClz{
        init{
            println("class init block") // 2
        }
    
        val subject by lazy{
            println("lazy init")  // 6
            "subject value"  // 7 lazy 리턴
        }
    
        fun flow(){
            println("not initialized") // 4
            println("call 1 : $subject") // 5 최초 초기화 시켜서 사용
            println("call 2 : $subject") // 8 이미 초기화 된 값을 사용
        }
    }
    
    fun main() {
        val test = LazyClz() // 1
        test.flow() // 3
    }
    
    // 실행 결과
    // class init block
    // not initialized
    // lazy init
    // call 1 : subject value
    // call 2 : subject value

`isInitialized`는 lateinit에서만 사용할 수 있다. 

?? 접근시 초기화면 비동기에선 문제없을까 ??

### 객체 지연 초기화

객체의 프로퍼티나 메서드에 최초 접근시에 초기화 됨.

    class Person(val name: String, val age: Int)
    
    fun main() {
    
        val person : Person by lazy{ // 객제 지연 초기화 블록
            println("Person Initialized")
            Person("COV",123)
        }
    
        val personDelegate = lazy{ // 지연 초기화 위임 (personDeligate엔 lazy 객체가 할당)
            println("Person Deligate Initialized")
            Person("KHS",321)
        }
    
    
        println(person.name) // 첫 접근 person의 lazy 블록이 실행됨
        println(personDelegate.value.name) // 첫 접근 personDelegate의 lazy 블록이 실행됨
    
        println(person.name) // 두번째 접근 초기화 된 값을 사용
        println(personDelegate.value.name) // 두번째 접근 초기화 된 값을 사용
    }
    
    // 출력 결과
    // Person Initialized
    // COV
    // Person Deligate Initialized
    // KHS
    // COV
    // KHS

`by lazy`는 객체의 위임을 나타냄

`lazy`는 Lazy 객체 자체를 나타내며 이 변수의 vlaue를 이용하여 호출해야 함.

### lazy 모드

`SYNCHRONIZED`: lock을 이용해 단일 스레드만이 사용하는 것을 보장(기본값)

`PUBLICATION`: 여러 군데서 호출될 수 있으나 처음 초기화 된 후 반환값을 사용한다.

`NONE`: lock을 사용하지 않기 떄문에 빠르지만 다중 스레드가 접근할 수 있다.(값의 일관성을 보장할 수 없음)

    private val model by lazy(mode = LazyThreadSafetyMode.NONE){
    	...
    }

## by를 이용한 위임

by를 사용하여 클래스를 위임하면 해당 클래스가 가지는 멤버를 참조 없이 호출 가능하게 됩니다.

    < val | var | class > 프로퍼티 혹은 클래스 이름: 자료형 by 위임자

### 클래스 위임

    interface Car{
        fun go(): String
    }
    
    class VanImpl(val power: String): Car{
        override fun go() = "은 짐을 적재하며 ${power}를 가집니다."
    }
    class SportImpl(val power: String): Car{
        override fun go() = "은 경주용이며 ${power}를 가집니다."
    }
    
    class CarModel(val model: String, impl: Car): Car by impl{
        fun carInfo(){
            println("$model ${go()}")
        }
    }
    
    fun main() {
        val damas = CarModel("Damas",VanImpl("100마력"))
        val m350z = CarModel("M350Z",SportImpl("350마력"))
    
        damas.carInfo() // 다형성을 가짐
        m350z.carInfo()
    
    		// damas.impl 이렇게는 사용할 수 없다. 프로퍼티 할당이 안되어있음!
    		// damas.go()는 된다.
    }

**※ 위임의 사용 이유**

open 키워드를 사용하지 않는 한 모든 클래스는 final 형태의 클래스 이다.

상속이나 직접 클래스의 기능 확장이 어렵게 되는데, 이로인해 무분별한 상속에 따른 복잡한 문제를 방지한다.

?? impl을 받아서 직접 사용하는거랑 무슨차이?

### 프로퍼티 위임과 by lazy

`by lazy`의 동작 분석 

1. lazy 람다식은 람다식을 전달받아 저장한 Lazy<T> 인스턴스를 반환한다.
2. 최초 프로퍼티의 게터 실행은 lazy에 넘겨진 람다식을 실행하고 결과를 기록한다.
3. 이후 프로퍼티의 게터 실행은 이미 초기화되어 기록된 값을 반환한다.

재 강조! 프로그램 시작 시 큰 객체의 초기화를 사용할 시점으로 늦추어 효율 향상

### observable() 함수의 사용

프로퍼티의 변경에 따른 이벤트 호출을 해줌!

    class User{
        var name: String by Delegates.observable("NONAME"){ // 프로퍼티 위임
            property, oldValue, newValue -> // 람다식 매개변수로 프로퍼티, 기존값, 새로운값
            println("$oldValue -> $newValue") // 이벤트 발생시 수행되는 부분
        }
    }
    
    fun main() {
        val user = User()
        user.name = "HSK" // 첫 이벤트 발생
        user.name = "COV" // 두번째 이벤트 발생
    }
    
    // 결과
    // NONAME -> HSK 
    // HSK -> COV

### vetoable() 함수의 사용

조건에 맞지 않으면 프로퍼티 업데이트를 거부하는 함수

    fun main() {
        var max: Int by Delegates.vetoable(0) { // 위임 // 초기값 0 
            property, oldValue, newValue -> // 람다식 매개변수로 프로퍼티, 기존값, 새로운값
            newValue > oldValue // 조건식 // true가 아니면 거부됨
        }
        
        println(max) // 0
        max = 10 // 기존 값보다 크므로 업데이트
        println(max) // 10
    
        max = 5 // 기존 값보다 작으므로 수행되지 않음
        println(max) // 10
    }
    
    // 결과
    // 0
    // 10
    // 10

### observable() 함수와 vetoable() 함수의 위임

`observable()`과 `vetoable()` 함수는 `kotlin.properties.Delegates`를 임포트 해야합니다.

observable()은 프로퍼티를 감시하고 있다가 변경이 일어날 때 호출됩니다. 콜백이라고도 함.

vetoable()은 observable과 비슷하지만 반환값에 따라 프로퍼티 변경을 허용하거나 취소할 수 있습니다.

TODO / 두 함수를 분석하여 위임이 어떻게 사용되는지 봐야함 ㅠ

# 정적 변수와 컴패니언 객체

동적인 초기화 없이 사용할 수 있는 변수!

정적 변수와 컴패니언 객체!

## 정적 변수와 컴패니언 객체

### 컴패니언 객체 사용하기

코틀린에는 `static`키워드가 없다! 그래서 `companion`을 제공한다.

해당 클래스에 컴패니언 객체를 구성하고 내부에 변수와 메서드를 구현해 놓을 수 있다.

컴패니언 객체는 싱글턴으로 정의됩니다.

    class Person{
    	var id: Int = 0
    	companion object{
    		var language: String = "Korean"
    		fun work(){
    			println("working...")
    		}
    	}
    }
    
    fun main(){
    	println(Person.language) // 값 호출 가능
    	Person.language = "English" // 값 변경 가능
    	Person.work() // 메서드 실행 가능
    }

### 코틀린에서 자바의 static 멤버 사용하기

똑같이 쓸 수 있다.

    Customer.Level
    Customer.login()

## 자바에서 코틀린의 컴패니언 객체 사용하기

코틀린에서 구현

    class KCustomer{
    	companion object{
    		const val LEVEL = "INTERMEDIATE" // const는 기본 자료형과 String에만 적용 가능
    		@JvmField val JOB = KJob() // 특정 자료형을 사용할 때 JvmField 어노테이션 사용
    
    		@JvmStatic fun login(){ // JvmStatic 어노테이션 사용
    			
    		}
    		fun logout(){
    			
    		}
    	}
    }

자바 코드에서 호출

    public static void main(String[] args){
    	System.out.println(KCustomer.LEVEL)
    	KCustomer.login() // 어노테이션 사용하였을때는 직접 가능
    	KCustomer.Companion.logout() // 어노테이션 미사용시 companion을 통해야
    	KCustomer.JOB.setTitle("Accountant")
    
    	KJob kjob = KCUstomer.JOB // 객체 생성 후 접근
    }

## 최상위 함수 사용하기

최상위 함수 역시 클래스나 객체 없이 단독으로 호출 가능

    fun packageLevelFunc(){
    }
    
    fun main(){
    	packageLevelFunc()
    }

**※ 디컴파일하여 보면 클래스가 만들어져 있음을 볼 수 있다.**

    public final class PackageLevelFunctionKt{
    	public static final void packageLevelFunc(){
    	}
    }

Java에서 호출

    public static void main(String[] args){
    	PackageLevelFunctionKt.packageLevelFunc()
    }

**※ 자동 생성되는 클래스명을 변경할 수 있다.**

    @file:JvmName("PKLevel")
    package a.b
    
    fun packageLevelFunc(){
    }

## object와 실글톤

### Object 선언

    // object 키워드를 사용한 방식
    object OCustomer{
        var name = "cov"
        fun greeting() = println("Hello World")
        val HOBBY = Hobby("Basketball")
    
        init{
            println("Init!")
        }
    }
    
    // 컴패니언 객체를 사용한 방식
    class CCustomer{
        companion object{
            const val HELLO = "hello"
            var name = "cov"
            @JvmField val HOBBY = Hobby("Football")
            @JvmStatic fun greeting() = println("Hello World")
        }
    }
    
    class Hobby(val name: String)
    
    fun main() {
        OCustomer.greeting()
        OCustomer.name = "HSK"
        println("name = ${OCustomer.name}")
        println(OCustomer.HOBBY.name)
    
        CCustomer.greeting()
        CCustomer.name = "HSK"
        println("name = ${CCustomer.name}, Hello = ${CCustomer.HELLO}")
        println(CCustomer.HOBBY.name)
    }

**※ object 키워드를 사용한 경우 특징**

- 멤버 프로퍼티와 함수를 객체 생성 없이 호출이 가능하다.

- 싱클턴으로 동작한다.

- 첫 멤버 프로퍼티나 함수에 접근할 때 초기화된다

- 클래스와 인터페이스를 상속할 수 있다.

- Java에서 사용하려면 `OCustomer.INSTANCE.getName()`과 같이 `INSTANCE`를 사용한다.

?? 너도 초기화 동기화는 ??

A: 안전하다~

[Objects and companion objects - Kotlin Programming Language](https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html)

### object 표현식

- object선언과 달리 이름이 없다.

- 싱클턴이 아니다.

- 표현식이 사용될 떄마다 새로운 인스턴스가 생성된다.

**※ 하위 클래스를 만들지 않고 특정 메서드를 오버라이딩 해보자**

    open class Superman{
        fun work() = println("Taking photos")
        fun talk() = println("Talking with people")
        open fun fly() = println("Flying in the air")
    }
    
    fun main(){
        val pretendedMan = object: Superman(){
            override fun fly() = println("I can't fly!")
        }
    
        pretendedMan.work()
        pretendedMan.talk()
        pretendedMan.fly()
    }

**※ 안드로이드에서는 리스너와 같이 딱 한번만 구현되어 사용 될 때 유용!**

    // 바로 구현하여 세팅
    window.addMouseListener(object: MouseAdapter(){
    	override fun mouseClicked(e: MouseEvent){
    	}
    
    	override fun mouseEntered(e: MouseEvent){
    	}
    })
    
    // 변수에 할당하여 여러번 쓰고싶으면
    val mouseAdapter = object: MouseAdapter(){
    	override fun mouseClicked(e: MouseEvent){
    	}
    
    	override fun mouseEntered(e: MouseEvent){
    	}
    }

**※ 객체는 필요하지만 상위 인터페이스나 클래스 구현은 안 해놓은 경우엔 다음처럼!**

    val adHoc = object{
    	var x = 0
    	var y = 0
    }
    
    print(adHoc.x + adHoc.y)

**※ 바로 바깥의 변수에 접근할 수 있다!**

    fun countClicks(window: JComponent){
    	var clickCount = 0
    	var enterCount = 0
    
    	window.addMouseListener(object: MouseAdapter(){
    		override fun mouseClicked(e: MouseEvent){
    			clickCount++
    		}
    	
    		override fun mouseEntered(e: MouseEvent){
    			enterCount++
    		}
    	})
    }

**※ 주의!**

- 익명 객체는 지역이나 private 정의 영역에서만 사용 가능

- public 함수의 반환 자료형이나 public 속성의 자료형으로 쓴다면 상위 자료형이 되거나 상위 자료형이 없으면 Any형이 됩니다.

    class C{
    	// private fun -> 반환 자료형은 익명 객체 자료형이 된다.
    	private fun foo() = object{
    		val x: String = "x"
    	}
    
    	// public fun -> 반환 자료형은 Any가 된다. 
    	fun publicFoo() = object{
    		val x: String = "x"
    	}
    	
    	fun bar(){
    		val x1 = foo().x // 문제없음
    		val x2 = publicFoo().x // Unresolved reference: x
    	}
    }