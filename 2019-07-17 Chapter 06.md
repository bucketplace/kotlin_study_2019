# 03. 함수와 함수형 프로그래밍

# 함수 선언하고 호출하기

## 함수란

- 여러 값(**인자**)을 입력 받아 기능을 수행하고 결과값을 반환하는 코드의 모음

- 함수는 코드를 재사용 할 수 있기 때문에 만든다.

## 함수의 구조

     1   2   3                4
    fun sum(a: Int, b: Int): Int{
    	5 var sum = a + b
    	6 return sum
    }

1. **fun** 

    모든 함수는 `fun` 키워드로 시작합니다. function을 줄인 말입니다.

2. **함수 이름**

    함수 이름에 키워드는 피한다.

    카멜 표기법을 사용한다.

3. **매개 변수**

    쉼표와 함께 여러개를 지정할 수 있다.

    반드시 자료형을 명시해 준다.

4. **반환값의 자료형**

    반환할 값의 자료형을 명시해 준다.

5. **함수의 본문**

    중괄호로 감싼 부분에 코드를 작성한다.

    여러줄도 가능

6. **값 반환**

    반환할 값을 명시한다.

    반환할 값이 없으면 생략해도 된다.(4번 반환값의 자료형을 지정안한경우)

### ※ 함수 간략하게 만들기

    fun sum(a: Int, b: Int): Int{
    	return a + b
    }

중괄호 안의 코드가 한줄이면 return문을 생략하고 대입 연산자를 사용할 수 있습니다.

    fun sum(a: Int, b: Int): Int **= a + b**

매개 변수와 연산을 타입 추론하여 반환값의 자료형도 생략 할 수 있습니다.

    fun sum(a: Int, b: Int) = a + b

## 함수 호출과 프로그램의 실행 순서

    **1**
    fun main() {
    									**2**
        val result1 = sum(3,2)
    									4
        val result2 = sum(6,4)
    
        println(result1)
        println(result2)
    }
    **3**,**5**
    fun sum(a: Int, b: Int) = a + b

1. **프로그램의 진입점 main 함수**

    `main()` 함수의 매개변수는 args인데 사용하지 않아서 지금은 생략

2. **함수의 호출과 함수의 인자**

    sum() 함수를 호출하며 인자는 3, 2를 사용하였습니다. 이는 sum 함수의 매개변수가 됩니다.

3. **sum()함수 호출**

    2에서 sum 함수를 호출하면 프로그램의 실행 흐름은 main 에서 sum으로 이동합니다. sum함수의 내부 로직이 수행되어 return 하게 되면 sum함수는 실행이 종료되며 프로그램의 흐름은 다시 main으로 돌아가게 됩니다.

4. **~ 5.는 2~3과 동일**

### 인자와 매개변수

함수를 선언할 때는 매개변수

함수를 호출할 때는 인자

? 인자는 함수의 매개변수에 복사되어 전달 된다구요?

1. 매개 변수는 val로서 변경 불가능

    ( java에서는 새로운 값을 할당 할 수 있지만, 기존 인자의 변수값이 바뀌진 않음 기본 자료형이던, 참조 자료형이던 )

2. java와 동일하게 참조 자료형의 내부 값을 바꾸는 경우 인자도 영향을 받음

## 함수의 호출과 메모리

    fun main(){ // 최초의 스택 프레임
    	val num1 = 10 // 임시 변수 혹은 지역 변수
    	val num2 = 3 // 임시 변수 혹은 지역 변수
    	val result: Int
    	
    	result = max(num1, num2) // 두 번째 스택 프레임
    	println(result)
    }
    
    fun max(a: Int, b: Int) = if ( a > b ) a else b

### 함수와 스택 프레임

함수를 호출하면 메모리에는 스택 프레임이 생긴다.

스택 영역을 높은 주소부터 차례대로 채워나간다.

함수의 지역 변수는 스택 프레임 내에 메모리를 할당 받으며, 스택 프레임에 종속되어 함수가 종료되면 스택 프레임과 함께 사라진다.

### 스택 프레임의 생성과 소멸

함수 a, b, c가 있을때 a에서 b를 b에서 c를 호출한다고 봅시다.

스택 프레임도 a, b, c 순서로 스택에 생성될 것입니다. 

함수의 종료 역시 c가 종료된 후 b가 종료되듯 역순으로 종료되어 스택 프레임도 c, b, a 순으로 소멸될 것입니다.

### ※ 스택이 최대 영역을 초과하면 스택 오버플로우 발생

스택은 높은 주소에서 낮은 주소로 채워져 가고

힙은 낮은 주소에서 높은 주소로 채워져 나갑니다.

둘이 만나면 스택 오버플로우가 발생하게 됩니다.

힙은 동적으로 생성된 객체의 정보가 담겨집니다.

## 반환값이 없는 함수

함수 내에서 출력하는 등 `return` 이 없을 경우 반환값은 `Unit`으로 지정할 수 있습니다.

    fun printSum(a: Int, b: Int): Unit {
    	println("sum of $a and $b is ${a+b}")
    }

다음은 `Unit`을 생략 한 것이고 이는 return 타입을 `Unit`으로 추론한 것 입니다.

    fun printSum(a: Int, b: Int){
    	println("sum of $a and $b is ${a+b}")
    }

자연스럽게 반환값을 입력하지 않게 되지만 `Unit`을 반환함을 항상 기억해 둡시다

### Unit과 void의 차이점

java의 void와 kotlin은 유사합니다.

void는 실제로 아무것도 반환하지 않지만, unit은 특수한 객체를 반환한다는 차이점이 있습니다.( 둘째 마당에서 자세히 설명할 것)

## 매개변수 제대로 활용하기

매개변수 중 필수 값이 아닌 것도 있을 것입니다. java에서는 오버로딩하여 기본값을 넣어 주었지만 코틀린에서는 간단하게 기본값을 지정할 수 있습니다.

as-is

    fun add(name: String, email: String){
    }
    
    // 이메일이 없다면 기본값을 아래와 같이 계속 넣어서 호출하게됨
    add("cov","default")
    add("liz","default")
    add("bsscco","default")

to-be

    fun add(name: String, email: String = "default"){
    }
    
    add("cov")

※ 모든 인자에 기본값을 집어넣을 수도 있습니다.

** 그래도 자바의 오버로딩은 실제로 1개의 매개변수만을 필요로 할 수 있으므로 차있는 있다!

### 매개변수 이름과 함께 함수 호출하기

매개변수가 너무 많은 함수를 호출할 때 어느 인자를 어느 매개변수에 전달했는지 헷깔린다!

그래서 순서와 상관없이 매개변수의 이름과 함께 인자를 전달하는 방법을 제공합니다.

    fun main(){
    	namedParam(x = 200, z = 100)
    	namedParam(z = 150)
    }
    
    fun namedParam(x: Int = 100, y: Int = 200, z: Int){
    	println(x + y + z)
    }

### 매개변수의 개수가 고정되지 않은 함수 사용하기 - 가변인자

같은 동작을 하는데 매개변수의 갯수에 따라 함수를 만들기 불편하다!

    fun print2Numbers(n1: Int, n2: Int){
    	// 각 숫자를 출력
    }
    
    fun print3Numbers(n1: Int, n2: Int, n3: Int){
    	// 각 숫자를 출력
    }

매개변수 왼쪽에 `vararg`라는 키워드를 붙이면 됩니다.

    fun normalVarargs(vararg counts: Int){
    	for (num in counts){
    		print("$num")	
    	}
    }

가변인자의 자료형은 `Int`로서 counts는 int형의 배열이 됩니다.

# 함수형 프로그래밍

코틀린은 함수형 언어(FP)와 객체지향 프로그래밍(OOP)를 모두 지원하는 **다중 패러다임 언어**입니다.

함수형 언어는 코드가 간략화되고 테스트나 재사용성이 더 좋아지면서 개발 생산성이 늘어나 꼭 공부해야 합니다!!

※ 다중 패러다임 언어란, 한 가지 구현 규칙에 얽매이지 않고 다양한 문법과 형식을 지원하는 언어를 말합니다. 현대의 컴퓨터 언어는 다중 패러다임 언어를 지향하며 발전하고 있습니다.

## 함수형 프로그래밍

순수 함수를 작성하여 프로그램의 부작용을 줄이는 프로그래밍 기법

순수 함수란?

### 순수 함수

**같은 인자에 대해 항상 같은 결과를 반환**하면 **부작용이 없는 함수** 라고 말합니다.

더불어 **외부의 어떤 상태도 바꾸지 않는다**면 **순수함수(pure function)** 이라고 합니다.

이런 특성으로 인해 순수함수는 **스레드에 사용해도 안전**하고 **코드를 테스트하기도 쉽다**는 장점이 있습니다.

※ 순수함수는 부작용이 없어 값이 예측이 가능해 **결정적(Deterministic)** 이라고 하기도 합니다.

프로그램이 커지다 보면 완벽히 통제하여 순수함수를 만들기는 어렵지만, 평소에 가능한 한 순수 함수에 가깝게 안전한 함수를 구현하려고 하는 노력이 중요합니다.

※ 순수 함수가 아닌 함수

    fun check(){
    	val test = User.grade()
    	if (test != null) process(test)
    }

chcek 함수에서 외부의 User.grade 함수를 실행하고 있으며, 이 결과값을 test에 저장하고 조건문에 사용합니다. 심지어 process 함수는 조건을 만족하지 않으면 실행하지도 않습니다. check 함수만 보면 user 가 어떤 객체인지 grade 함수는 어떤 값을 반환하는지 process는 무엇을 하는지 알 수 없습니다.

이런 함수가 조건을 만족하지 못하는 함수입니다.

### 람다식

람다 대수에서 유래하였습니다.

람다 대수는 이름이 없는 함수로 2개 이상의 입력을 1개의 출력으로 단순화한다는 개념입니다.

함수형 프로그래밍의 람다식

- 다른 함수의 인자로 넘기는 함수
- 변수에 저장하는 함수
- 함수의 결과값으로 반환하는 함수

람다식의 형태

    {x, y -> x + y}

### 일급 객체

함수형 프로그래밍에서는 함수를 일급 객체로 생각합니다.

람다식 역시 일급 객체의 특성을 가지고 있습니다.

**일급 객체의 특징**

- 일급 객체는 함수의 인자로 전달할 수 있다.
- 일급 객체는 함수의 반환값에 사용할 수 있다.
- 일급 객체는 변수에 담을 수 있다.

함수가 일급 객체라면 **일급 함수**라고 부릅니다.

이 일급 함수에 이름이 없는 경우 **람다식 함수** 혹은 **람다식**이라고 부를 수 있습니다.

**즉, 람다식은 일급 객체의 특징을 가진 이름없는 함수 입니다.**

### 고차 함수

다른 함수를 인자로 사용하거나 함수를 결괏값으로 반환하는 함수를 말합니다.

객체 혹은 일급 함수를 서로 주고받을 수 있는 함수가 고차함수가 됩니다.

    fun main(){
    	println(highFunc({x,y -> x + y}, 10, 20)
    }
    
    fun highFunc(sum: (Int, Int) -> Int, a: Int, b: Int): Int = sum(a,b)

### 함수형 프로그래밍의 정의와 특징

- 순수 함수를 사용해야 한다.
- 람다식을 사용할 수 있다.
- 고차 함수를 사용할 수 있다.

# 고차 함수와 람다식

고차 함수는 인자나 반환값에 함수를 사용하기 때문에 매우 유연함!

처음에는 적응하기 어려울 수 있지만 익숙해지면 간결하고 최적화된 코드를 작성할 수 있습니다.

? 함수를 두개 전달해서 골라쓰는 등 하면 헷깔리지 않을까 ?

## 고차함수의 형태

### 일반 함수를 인자나 반환값으로 사용하는 고차 함수

일반 함수를 인자로 사용함

    fun main(){
    	val res1 = sum(3,2) // 일반 인자
    	val res2 = mul(sum(3,3),3) // 인자에 함수를 사용
    	println("res1 : $res1 res2: $res2")
    }
    
    fun sum(a: Int, b: Int) = a + b
    fun mul(a: Int, b: Int) = a * b

? 함수를 전달한게 아니라 계산된 값을 전달하는게 아닌가 함수형 언어의 특성임이 이걸로 생각이 되려나?

일반 함수를 반환값으로 사용

    fun main(){
    	println("funcFunc: ${funcFunc()}")
    }
    
    fun sum(a: Int, b: Int) = a + b
    
    fun funcFunc(): Int{
    	return sum(2,2)
    }

### 람다식을 인자나 반환값으로 사용하는 고차함수

**변수에 할당하는 람다식 함수**

    fun main(){
    	val result: Int
    	val multi = {x: Int, y: Int -> x * y}
    	result = mylti(10, 20)
    	println(result)
    }

**람다식의 선언과 할당**

    	 1                 **2**                 3            **4**
    val multi: **(Int, Int) -> Int** = {x: Int, y: Int -> **x * y**}

1. **변수를 함수처럼 사용 가능**
2. **람다식의 자료형 선언**

    람다식 매개변수에 자료형이 명시된 경우 생략 가능

        val multi = {x: Int, y: Int -> x * y**}**

3. **람다식의 매개변수**

    선언 자료형이 명시되어있으면 생략 가능

        val multi: **(**Int, Int) -> Int = {x, y -> x * y}

4. **람다식의 처리 내용**

    표현식이 여러 줄인 경우 마지막 표현식이 반환

        val multi: **(Int, Int) -> Int** = {x: Int, y: Int -> 
        	println("x * y")	
        	**x * y // 마지막 표현식이 반환**
        }

**매개변수가 없는 경우**

    val greet: () -> Unit = {println("hello world!")}
    // () -> Unit 이 생략 가능하지만 추론 되어있음을 계속 인지할 것
    val greet = {println("hello world!")}

**람다식 안에 람다식을 넣을 경우에 자료형 지정**

    val nestedLambda: () -> () -> Unit = {{println("hello world!")}}
    // 이 상황에서도 추론 가능
    val nestedLambda = {{println("hello world!")}}

**매개변수와 인자에 람다식을 사용한 고차함수**

    fun main(){
    	var result: Int
    	result = highOrder({x, y -> x + y}, 10, 10)
    	println(result)
    }
    
    fun highOrder(sum: (Int, Int) -> Int, a: Int, b: Int){
    	return sum(a,b)
    }

**인자와 반환값이 없는 람다식 함수**

    fun main(){
    	val out = {println("Hello World!")}
    
    	out() // 함수처럼 사용 가능
    	val new = out // 다른 변수에 할당
    	new() // 사용 가능
    }

## 람다식과 고차 함수 호출하기

함수의 내용을 할당하거나 인자 혹은 반환값을 자유롭게 넘기려면 **호출 방법**을 이해해야 합니다.

**기본형 변수**로 할당된 값은 스택에 있고 다른 함수에 인자로 전달하는 경우에는 값이 복사되어 전달됩니다.

**참조형 변수**로 할당된 객체는 참조 주소가 스택에 있고 객체는 힙에 있습니다. 함수에 전달할 때는 참조된 주소가 복사되어 전달됩니다.

자바나 코틀린은 함수를 호출할 때 인자의 값만 복사합니다.

이는 **값에 의한 호출(Call by Value)**이라고 합니다.

C, C++은 포인터 주소 연산을 하며 주소 자체를 사용해 호출하는 **참조에 의한 호출(Call by Reference)** 방법을 사용합니다.

### 값에 의한 호출

함수가 다른 함수의 인자로 전달 될 경우 람다식 함수는 값으로 처리되어 그 즉시 함수가 수행된 후 값을 전달합니다.

    fun main(){
    	val result = callByValue(lambda())
    }
    
    fun callByValue(b: Boolean): Boolean{
    	println("call by value")
    	return b
    }
    
    val lambda: () -> Boolean = {
    	println("lambda function")
    	true
    }
    
    //결과
    //lambda function
    //call by value

### 이름에 의한 람다식 호출

람다식의 이름을 인자로 전달하여 바로 실행되지 않고 실제 호출할 때 실행되도록 구현.

    fun main(){
    	val result = callByName(lambda) // 람다식 이름으로 호출
    }
    
    fun callByName(b: () -> Boolean): Boolean{// 매개 변수를 람다식 자료형으로 선언
    	println("call by name")
    	return b()
    }
    
    val lambda: () -> Boolean = {
    	println("lambda function")
    	true
    }
    
    //결과 
    // call by name
    // lambda function

### 다른 함수의 참조에 의한 일반 함수 호출

람다식이 아닌 일반 함수를 이름에 의한 호출로 구현

**`::함수명`**표현을 사용

    fun main(){
    	val res1 = funcParam(3,2,::sum)//일반 함수의 참조를 전달
    
    	val likeLambda = ::sum // 일반 함수를 람다식처럼 변수에 할당
    	likeLambda(3,2)
    }
    
    fun sum(a: Int, b: Int) = a + b
    
    fun funcParam(a: Int, b: int, c: (Int, Int) -> Int): Int{
    		return c(a,b)
    }

:: 표기법 정리

    hello(::text)
    hello({a, b -> text(a,b)})
    hello {a, b -> text(a,b)}

## 람다식의 매개변수

매개변수에 따른 람다식 구성 방법을 공부할 것.

인자 개수에 따라 생략된 표현이 가능하여 코드를 간략화 할 수 있음!

### 람다식에 매개변수가 없을 때

소괄호 생략 가능

    fun main(){
    	noParam({"Hello World!"})
    	noParam{"Hello World!"}
    }
    
    fun noParam(out: () -> String) = println(out())
    // return이 String이고 매개 변수가 없는 함수

### 람다식의 매개변수가 1개인 경우

람다식 왼쪽에 `변수 →` 처럼 필요한 변수를 써주어야 합니다.

`변수 →` 생략하며 `it`을 사용할 수 있습니다. 

    oneParam({a -> "Hello World! $a"})
    oneParam{a -> "Hello World! $a"} // 소괄호 생략 가능
    oneParam{"Hello World! $it"} // **변수 ->** 를 **it**으로 사용 가능
    
    fun oneParam(out : (String) -> String) = println(out("oneParam"))

? $a 와 같이 사용하는것의 이름은? - 인터폴레이션

? it 이것의 이름은? it 매개변수? - 

### 람다식의 매개변수가 2개 이상인 경우

매개 변수 이름 생략 `it`을 사용할 수 없음!

매개 변수를 사용하지 않을 경우 `_` 로 무시 가능!

    moreParam {a, b -> "Hello World! $a $b"} // 매개변수 이름 생략 불가(it 못씀)
    
    moreParam {_, b -> "Hello World! $b"} // 매개변수를 사용 안하고 싶을 경우 _ 로 대체
    
    fun moreParam(out : (String) -> String) = println(out("oneParam"))

### 일반 매개변수와 람다식 매개변수를 같이 사용하기

함수의 매개변수 중 **마지막이 람다식인 경우** 함수 호출시 소괄호에서 분리 가능!

    fun main(){
    	withArgs("Arg1", "Arg2", {a, b-> "Hello World! $a $b"})
    	
    	//withArgs의 **마지막 인자가 람다식인 경우** 소괄호 바깥으로 분리가능
    	withArgs("Arg1", "Arg2") {a, b-> "Hello World! $a $b"}
    }
    
    fun withArgs(arg1: String, arg2: String, out: (String, String) -> String){
    	println(out(arg1,arg2))
    }

### 일반 함수에 람다식 매개변수를 2개 이상 사용하기

이 경우엔 소괄호 생략 불가!

하지만 이전 조건처럼 마지막 람다 매개변수는 소괄호 밖으로 분리가능!

→ 하지만 헷깔리지 않을까?

    fun main(){
    	twoLambda({a, b -> "First $a $b"}, {"Second $it"})
    	twoLambda({a, b -> "First $a $b"}) {"Second $it"}
    }
    
    fun twoLambda(first: (String, String)-> String, second: (String) -> String){
    	println(first("oneParam", "twoParam"))
    	println(second("oneParam"))
    }

마찬가지로 3개 이상일 때도 마지막 람다 매개변수는 소괄도 바깥으로 분리 가능!

    ({첫 번째}, {두 번째}) {세 번째}

? 괄호가 헷깔리지 않을까? → 소괄호를 미리 닫아서 신경 안써도 되는 장점!

# 고차 함수와 람다식의 사례

다소 어려운 내용이 있을 수 있으나, 이렇게도 사용하고 있구나 정도로 이해하고 넘어가면 좋데요..

## 동기화를 위한 코드 구현

**동기화**란 변경이 일어나면 안되는 특정 코드를 보호하기 위한 잠금 기법

동기화로 보호되는 코드는 **임계영역(Critical section)** 이라고도 합니다.

자바에서는 Lock과 ReentrantLock을 제공하고 있습니다.

공유 자원에 접근한다고 했을 때 임계 영역의 코드를 잠가 두었다가 사용한 후 풀어주는 방법입니다.

? 나는 세마포어를 쓰는걸로 알고있는데 어떻게 다른거지 ? - 동시 처리의 갯수를 지정할 수 있다.

    Lock lock = new ReentrantLock();
    lock.lock(); // 잠금
    try {
    	// 보호할 임계 영역 코드
    	// 수행할 작업
    } finally{
    	lock.unlock(); //해제
    }

이 코드를 특정함수를 보호하기 위한 고차함수로 만들어 봅시다.

    fun <T> lock(reLock: ReetrantLock, body: () -> T): T{
    	reLock.lock()
    	try{
    		return body()
    	} finally {
    		reLock.unlcok()
    	}
    }

보호하는 고차함수를 한번 사용해 봅시다.

    // 공유 자원
    var sharable = 1
    
    fun main(){
    	var reLock = ReentrantLock()
    	
    	// 다음 표현 3가지는 모두 동일
    	lock(reLock, {criticalFunc()})
    	lock(reLock) {criticalFunc()}
    	lock(reLock, ::criticalFunc)
    
    	println(sharable)
    }
    
    fun criticalFun(){
    	// 공유 자원 접근 코드
    	shareable += 1
    }

? 잠겨있으면 기다리나? syncronized와 어떻게 다른가?

? 람다식을 매개변수로 쓸 때 제너릭도 추론하나? 제너릭은 9장에서 자세히 다룬데요

? 이거는 원래 동기화 코드가 아닌거같다 ?

## 네트워크 호출 구현 구경하기

네트워크 호출을 하고 성공하거나 실패했을 때 특정 콜백 함수를 처리하는 프로그램을 만들어 봅시다.

※ 자바와 코틀린을 비교해 볼것입니다.

자바에서의 콜백 인터페이스와 구현

    public interface Callback{
    	void onSuccess(ResultType result);
    	void onError(Exception exception);
    }
    
    // network 통신 구현
    public void networkCall(Call callback){
    	try { 
    		// 통신 코드 - 성공하면 onSuccess 호출
    		callback.onSuccess(myResult);
    	} catch (e: Throwable){
    		callback.onError(e);	
    	}
    }
    
    // network 통신 사용
    network(new Callback(){
    	public void onSuccess(ResultType result){
    		// 성공시 처리
    	}
    	
    	public void onError(Exception exception){
    		//에러시 처리	
    	}
    })

코틀린 설계로 구현

    // network 구현
    fun networkCall(onSuccess: (ResultTyle) -> Unit, onError: (Throwable) -> Unit){
    	try{
    		// 통신 구현
    		onSuccess(myResult)
    	}catch(e: Throwable){
    		onError(e)
    	}
    }
    
    // network 사용
    networkCall(result -> {
    	// 네트워크 성공 처리
    }, error -> {
    	// 네트워크 실패 처리
    })

인터페이스나 익명 객체 없이 성공과 실패의 구현을 강제할 수 있어서 간결.

# 코틀린의 다양한 함수 알아보기

일반 함수

고차 함수

람다식 함수

익명 함수

인라인 함수

확장 함수

중위 함수

등

## 익명 함수

일반 함수이지만 이름이 없는 것 입니다.

    fun(x: Int, y: Int): Int = x + y // 함수 이름이 없다.
    
    val add: (Int, Int) -> Int = fun(x, y) = x + y // 익명함수를 사용한 add 선언
    val result = add(10,2) // add 사용
    
    // 람다식과 동일하게 매개변수에 자료형을 넣어주면 선언부에서 생략 가능
    val add = fun(x: Int, y: Int) = x + y // 익명함수를 사용한 add 선언
    
    // 람다식과 유사하여 람다식으로 표현 가능
    val add = {x: Int, y: Int -> x + y}

### **람다식과 똑같은데 왜 사용할까?**

**람다식에서는 return 이나 break, continue처럼 제어문을 사용하기 어렵기 때문!**

람다식에서 return을 사용하려면 라벨 표기법을 사용하여야 하고 4장 흐름제어에서 배워봅시다.

## 인라인 함수

- 인라인 함수는 함수가 호출되는 곳에 함수 본문의 내용을 복사해 넣어버리는 함수 ( xml import처럼 )

- 분기 없이 처리되기 때문에 코드의 성능을 높일 수 있음

- 대개 짧게 작성

- 람다식 매개변수를 가지고 있는 함수에서 동작

- 람다식의 내용도 복사됩니다.

※ 보통 함수는 다른 코드로 분기해야 하기 때문에 기존 내용을 저장 해야하고, 돌아올때 복구하는 작업에 프로세스와 메모리를 꽤 사용해야하는 비용이 듭니다.

?? 인라인 함수가 효과적이라고 하고, 디컴파일시 좋을 것 같은데 왜 자주 안쓰일까?

**인라인 함수 구현**

    fun main(){
    	shortFunc(3) { println("First call: $it") }
    	shortFunc(5) { println("Second call: $it") }
    }
    
    inline fun shortFunc(a: Int, out: (Int) -> Unit){
    	println("Before calling out()")
    	out(a)
    	println("After calling out()")
    }

**컴파일 된 인라인 함수**

    // 1회 복사 시작
    int a$iv = 3;
    int $i$f$shortFunc = false;
    String var2 = "Before calling out()";
    boolean var3 = false;
    System.out.println(var2);
    int var5 = false;
    String var6 = "First call: " + a$iv;
    boolean var7 = false;
    System.out.println(var6);
    var2 = "After calling out()";
    var3 = false;
    System.out.println(var2);
    
    // 2회 복사 시작
    a$iv = 5;
    $i$f$shortFunc = false;
    var2 = "Before calling out()";
    var3 = false;
    System.out.println(var2);
    var5 = false;
    var6 = "Second call: " + a$iv;
    var7 = false;
    System.out.println(var6);
    var2 = "After calling out()";
    var3 = false;
    System.out.println(var2);

### 인라인 함수 제한하기

- 인라인 함수의 매개변수인 람다식이 너무 길거나 인라인 함수가 너무 길 경우 컴파일러에서 성능 경고를 할 수 있습니다.

- 람다식 매개변수를 인라인 함수가 되지 않게 하는 방법

    inline fun sub(out1: () -> Unit, noinline out2: () -> Unit)

### 인라인 함수와 비지역 반환

익명 함수를 종료하기 위해서는 값을 반환하지 않는 return을 사용할 수 있습니다. 

※ 인라인 함수에서 사용되는 람다식은 return문을 사용할 수 있습니다.

**인라인 함수에서 사용한 람다식을 빠져나오는 방법**

    fun main(){
    	shortFunc(3){
    		print("First call: ${it}")
    		return
    	}
    }
    
    inline fun shortFun(a: Int, out: (Int) -> Unit){
    	println("Before calling out()")
    	out(a)
    	println("After calling out()")
    }
    
    //결과값
    // Before calling out()
    // First call : 3

After calling out()이 호출 되지 않는 것을 볼 수 있습니다.

람다식에서 return문을 만났지만 의도치 않게 바깥의 shortFun()이 반환처리 되는것을 **비지역 반환**이라고 합니다.

**비지역 반환을 금지하는 방법**

    fun main(){
    	shortFunc(3){
    		print("First call: ${it}")
    		**// return 사용 불가**
    	}
    }
    
    inline fun shortFun(a: Int, **crossinline** out: (Int) -> Unit){
    	println("Before calling out()")
    	**nestedFunc(out(a))**
    	println("After calling out()")
    }
    
    **fun nestedFunc(body: () -> Unit){
    	body()
    }**
    
    //결과값
    // Before calling out()
    // First call : 3
    // After calling out()

**crossinline** 키워드는 비지역 반환을 금지해야 하는 람다식에 사용합니다. 

위와 같이 문맥이 달라져 인라인이 되지않는 중첩된 람다식 함수는 nestedFunc() 함수 때문에 return을 금지해야 합니다.

## 확장 함수

**멤버 메서드** - 클래스에 이미 정의되어 있는 함수`

**확장 함수** - 멤버 메서드는 아니지만 기존 클래스에 내가 원하는 함수를 하나 더 포함시키는 것

사용방법

    fun 확장 대상.함수이름(매개변수, ...): 반환값 {
    	...
    	return 값
    }

※ Any 클래스에 확장 함수를 만들면 모든 클래스에서 사용 가능해진다!

### String 클래스에 나만의 확장함수 추가하기

더 긴 문자열 비교!

    fun main(){
    	val source = "Hello World!"
    	val target = "kotlin"
    	println(source.getLongString(target))
    }
    
    fun String.getLongString(target: String): String = 
    	if(this.length > target.length) this else target

※ 동일한 멤버 함수가 있다면 항상 확장 함수보다 멤버 메서드가 우선으로 호출됩니다.

?? private 함수로 이미 있다면 ??

## 중위 함수

함수를 호출할 때 점과 소괄호를 생략 가능!

**중위 함수의 조건**

- **멤버 메서드** 또는 **확장 함수**여야 한다.

- **하나의 매개변수**를 가져야 한다.

- `infix` 키워드를 사용하여 정의한다.

    main()
    	val multi = 3 multiply 10
    }
    
    **infix** fun Int.**multiply**(x: Int): Int{
    	return this * x
    **}**

## 꼬리 재귀 함수

**재귀** : 자기 자신을 다시 참조하는 방법

**재귀 함수의 조건**

- 무한 호출에 빠지지 않도록 탈출 조건을 만들어 둔다.

- 스택 영역을 이용하므로 호출 횟수를 무리하게 많이 지정해 연산하지 않는다.

- 코드를 복잡하지 않게 한다.

코틀린에서는 꼬리 재귀 함수를 통해 스택 오버플로 현상을 해결할 수 있습니다.

스택에 계속 쌓이는 방식이 아닌 꼬리를 무는 형태로 반복

`tailrec` 키워드를 사용

### 일반적인 factorial 재귀 함수

    fun factorial(n: Int): Long{
    	return if (n == 1) n.toLong() else n * factorial(n-1)
    }

※ 재귀함수로 4번 호출이 되면 문맥을 유지하기 위해 스택 메모리를 4배만큼 더 사용합니다.

### 꼬리 재귀 함수

일반적인 재귀함수는 재귀함수 호출 후 계산되지만 꼬리재귀 함수는 계산을 먼저 한 뒤 재귀함수를 호출 합니다.

    tailrec fun factorial(n: Int, **run: Int = 1**): Long{
    	return if(n==1) run.toLong() else fatorial(n-1, **run * n**)
    }

### 피보나치 수열 재귀 함수와 꼬리 재귀 함수

    tailrec fun fibonacci(n: Int, a: BigInteger, b: BigInteger): BigInteger{
    	return if ( n == 0 ) a else fibonacci(n-1, b, a + b)
    }

※ 2만번을 호출해도 스택 오버플로 문제가 없다!

# 함수와 변수의 범위

함수는 실행블록**{}**을 가지고 있습니다.

**{** 에서 함수가 실행되며 **}** 에서 함수가 종료되며 가지고 있는 지역 변수를 삭제 합니다.

블록 내에 함수를 정의하면 **지역 함수**가 됩니다. 

지역 함수도 사용하려면 먼저 선언해야 합니다

지역 함수도 블록이 종료되면 같이 삭제됩니다.

## 함수의 범위

### 최상위 함수와 지역 함수

**최상위 함수** : 파일을 만들고 곧바로 만들어진 main() 이나 사용자 함수.

**지역 함수 :** 함수 안에 선언된 함수

### 최상위 및 지역 함수의 사용 범위

    fun main(){// 최상위 함수
    
    	secondFun(3) // **에러!!**
    
    	fun secondFun(a: Int){ // 지역 함수
    	}
    	
    	userFun(1) // 최상위 함수는 선언부의 위치에 상관없이 사용 가능
    	secondFun(4) // 지역 함수는 선언부가 먼저 나와야 사용 가능
    
    	c() // **에러!!** c 함수는 userFun 블록을 벗어난 곳에서 사용할 수 없음
    ****
    }
    
    fun userFun(const: Int){// 사용자가 만든 최상위 함수
    	fun c(){ // userFun의 지역함수
    	}
    }

## 변수의 범위

### 지역 변수와 전역 변수

**지역 변수** : 특정 코드 블록 안에 있는 변수

블록이 종료되면 프로그램 메모리에서 더이상 사용되지 않고 삭제됩니다.

**전역 변수** : 최상위에 있는 변수

프로그램이 실행되는 동안 값이 유지됨

전역변수에 동시 접근하는 코드들에 잘못된 동작을 유발할 수 있다.

자주 사용되지 않는 변수는 메모리 자원 낭비이다.

    package chap03.section6
    
    var global = 10 // section6 패키지 전체에 적용되는 **전역 변수**
    
    fun main(){
    	val local1 = 20 // main 함수 블록 안에서만 유지되는 **지역 변수**
    	val local2 = 21
    
    	fun nestedFunc(){
    		global += 1
    		val local1 = 30 // nestedFunc 안에서만 유지됨 ( 기존 main의 local1 변수는 가려짐 )
    		println("nestedFunc local1: $local1")
    		println("nestedFunc local2: $local2") // main 함수의 local2가 사용됨
    		println("nestedFunc global: $global")
    	}
    
    	nestedFunc()
    	outsideFunc()
    
    	println("main global: $global")	
    	println("main local1: $local1")
    	println("main local2: $local2")
    }
    
    fun outsideFunc(){
    	**global** += 1
    	val **outVal** = "outside"
    	println("outsideFunc global: $global")	
    	println("outsideFunc outVal: $outVal")
    }