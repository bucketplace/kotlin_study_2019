# 07 다양한 클래스와 인터페이스

### 01 추상 클래스와 인터페이스

---

**abstract 클래스 정의하기**

    abstract class Vehicle {
    	abstract var maxSpeed: Double // 추상 프로퍼티
    	abstract fun start() // 추상 메소드
    }

**익명 객체 생성하기**

    val myPainter = object : Painter() {
    	...
    }

**인터페이스 정의하기**

    interface Per {
    	var category: String // 추상 프로퍼티
    	fun feeding() // 추상 메소드
    	fun patting() { // Java에서의 default 메소드
    		println("$category !")
    	}
    }

**구현체에서 인터페이스에 접근하기**

여러 인터페이스를 구현한 경우에 인터페이스끼리 메소드가 겹치면 어떤 메소드를 사용할지 선택할 수 있다.

    class Pegasus : Bird, Horse {
    	override fun jump() {
    		super<Horse>.jump()
    	}
    }

**인터페이스를 위임하기**

구현체를 생성자 매개변수로 받는 경우에 구현체의 public 기능을 현재 클래스의 것처럼 포함시킬 수 있다.

    interface Inf {
    	fun foo() { ... }
    }
    
    class Concrete(val impl: Inf) Inf by impl {
    	fun bar() {
    		foo() // impl.foo()에서 impl. 를 뺄 수 있음.
    	}
    }

### 02 데이터 클래스와 기타 클래스

---

**DTO(Data Transfer Object)란?**

- = Java POJO
- getter/setter, toString(), equals() 등을 가져야 한다.

**data 클래스에서 자동생성되는 요소**

- getter/setter
- equals(), hashCode()
- toString()
- copy() : 특정 프로퍼티만 변경해서 복사하는 용도
- component1(), component2(), ... : 구조 분해(destructuring) 용도

**data 클래스의 정의 규칙**

- 주 생성자는 최소 하나의 매개변수를 가져야 한다.
- 주 생성자의 모든 매개변수는 var, val로 지정되어야 한다.
- abstract, open, sealed, inner 키워드를 사용할 수 없다.

**nested 클래스란?**

Java의 nested static 클래스와 동일 

**inner 클래스란?**

Java의 inner 클래스와 동일

**지역 클래스란?**

블록 안에서 선언된 클래스. 블록이 끝나면 사용할 수 없다.

**익명 클래스(익명 객체)란?**

Java의 익명 클래스와 동일

**sealed 클래스란?**

- 같은 파일 안에서만 상속이 가능하기 때문에 자료형들을 묶어서 제공하기에 좋다.
- enum의 확장형이라고 볼 수 있다.
- 경우의 수가 한정되므로 when문에서 else를 구현할 필요가 없다.

**enum 클래스란?**

- Java의 열거형 클래스와 동일
- sealed 클래스처럼 다양한 자료형을 다루진 못한다.

**annotation 클래스란?**

- @ 기호화 함께 나타내는 표기법
- 주로 컴파일러나 런타임에 사전처리를 위해 사용한다.

**annotation 사용하기**

    @Fancy class MyClass @Fancy constructor(val prop: Int) {
    
    	@Fancy fun myMethod(@Fancy myProperty: Int): Int {
    		return (@Fancy 1)
    	}
    }

**표준 어노테이션**

- @JvmName : Kotlin에서 식별자 이름을 Java로 컴파일 하면서 지정한 이름으로 바꿔준다.
- @JvmStatic : Companion 안의 메소드나 object(싱클톤) 클래스의 메소드를 Java로 컴파일 하면서 static 메소드로 바꿔준다.
- @Throws : Kotlin의 throw 구문이 있는 곳에 대해 Java로 컴파일 하면서 필요한 메소드 선언부에 throws가 포함되도록 한다.
- @JvmOverloads : Kotlin 매개변수에 디폴트값이 적용된 곳에 대해 Java로 컴파일 하면서 필요한 오버로딩 함수를 만들어준다.

### 03 연산자 오버로딩

---

**연산자 오버로딩 하기**

Java와 달리 operator 키워드를 붙여주어야 하고 지정된 연산자명을 메소드명으로 써야 한다.

**동등성 연산자 주의점**

- a == b 에서 둘다 a, b 둘 다 null일 때 true를 반환
