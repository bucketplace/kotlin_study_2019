# 10 표준 함수와 파일 입출력

### 들어가면서

- 표준함수를 사용하면 복잡한 표현식을 단순화 할 수 있다. (let, also, apply, run, with, use 등)
- 람다식과 확장함수를 이용하면 사용자정의 언어 DSL을 만들 수 있다.

### 01 코틀린 표준 함수

---

**클로저**

람다 내부에서 외부 변수를 사용할 수 있도록 외부 변수의 참조를 캡처한 변수

**클로저의 조건**

- 외부 변수는 final 변수여야 한다.
- 자바(레트로 람다 사용은 제외)와 달리 final이 아닌 외부 변수는 컴파일러가 자동으로 final 래퍼로 감싸서 래퍼의 참조를 캡처한다.

[(람다식을 사용하는) 표준 함수](https://www.notion.so/6c7643ee836c4749bc755ccb8c21f618)

제네릭의 확장함수라서 어느 객체에서든 사용할 수 있다.

**let 함수를 사용할 때**

- null 체크 후 로직을 실행할 때
- 다른 형으로 변형해서 사용할 때

**also 함수를 사용할 때**

객체의 멤버를 변경하지 않고 참조하기만 할 때 

**apply 함수를 사용할 때**

여러 줄의 객체 초기화 코드가 있을 때

**run 함수를 사용할 때**

서로 관련된 코드를 블록 단위로 묶을 때

**use 함수를 사용할 때**

사용 후 close()를 호출이 필요한 Closeable 객체를 사용할 때

**takeIf 함수를 사용할 때**

특정 조건이 true일 때만 로직을 실행할 때

**takeUnless 함수를 사용할 때**

특정 조건이 false일 때만 로직을 실행할 때

measureTimeMillis, measureNanoTime 함수를 사용할 때

로직의 수행 시간을 측정할 때

**난수 생성**

kotlin.random.Random 패키지는 자바와 달리 멀티플랫폼에서도 사용 가능하다.

### 02 람다식과 DSL

---

**람다와 확장함수 등을 사용하면 DSL을 정의할 수 있다.**

    data class Person(var name: String? = null, var job: Job? = null)
    data class Job(position: String? = null)
    
    // 매개변수 block에 지역 확장함수를 사용
    fun person(block: Person.() -> Unit): Person {
    	// 새 Person 객체를 block으로 넘겨서 block을 실행
    	return Person().apply(block)
    }
    
    // Person객체의 job 함수를 구현
    fun Person.job(block: Job.() -> Unit) {
    	job = Job().apply(block)
    }
    
    // DSL 사용
    val p = person {
    	name = "BSSCCO"
    	job {
    		position = "Android Dev"
    	{
    }

**DSL 활용 사례**

- Spring 프레임워크
- Spark 프레임워크
- Ktor 프레임워크

### 03 파일 입출력

---

**스트림(java.io)과 채널(java.nio)**

- 스트림 : 단방향 입력 또는 출력
- 채널 : 양방향 입출력

**버퍼**

- 스트림은 버퍼 기능을 사용하려면 XXXBuffer와 병합해 사용해야 한다.
- 채널은 버퍼를 기본적 사용한다.
