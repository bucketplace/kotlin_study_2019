# 2. 변수와 자료형, 연산자

# **02-1 코틀린 패키지**

## 코틀린 프로젝트 구성 (여행)

- 모듈 (목적지)
- 패키지 (여행용 가방)
- 파일 ( 가방 속에 넣은 짐)

### 모듈

- 대규모 프로젝트를 진행할 때 기능을 모듈로 분리

### 패키지

- 파일의 폴더링 구조
- 두 명 이상의 프로그래머가 같은 이름의 파일을 만들 때 구분하기 위함
- 패키지의 이름은 특수 문자나 숫자로 시작하면 안됨
- 여러 단계의 분류는 . 으로 구분
- 다른 패키지의 것을 사용할 때에는 import로 상단에 선언 해주어야 함

    → import 할 때 패지키의 여러 요소를 한꺼번에 가져오기 위해 *을 사용할 수 있지만, 모든 코드를 가져오기 때문에 용량이 늘어나 코드 최적화에 문제가 될 수 있기 때문에 사용할 요소만 import할 것을 권장

- import한 클래스의 이름을 변경하여 사용하고 싶을 때에는 패키지 이름 뒤에 as 사용

    **default 패키지**

    - src 폴더에 따로 이름이 지정되지 않은 패키지
    - 코틀린 파일 안에 패키지 이름을 선언하지 않으면 자동으로 default 패키지에 포함

    **기본 패키지**

    - import 하지 않아도 기본으로 사용할 수 있는 패키지 (p.45 참조)

### 파일

- 파일에 1개의 클래스가 정의되어 있고 해당 클래스 이름과 파일의 이름이 같으면 파일에 클래스 이름만 보임
- 파일에 여러 개의 클래스를 정의되어 있거나 파일과 클래스의 이름이 다르면 파일 이름 뒤에 .kt 확장자가 붙음

# **02-1 변수와 자료형**

## 변수

- 변수는 val, var 키워드 이용하여 선언

    val : 최초로 지정한 변수의 값으로 초기화, 추후 값을 바꿀 수 없는 읽기 전용 변수

    var : 값을 바꿀 수 있는 변수 

    → val로 선언하고 변경해야할 일이 생길 때 var로 가꾸는 방법 권장

- val username: String = "kildong"      =    val username = "kildong"

    → 자료형 추론 : 코틀린은 값을 가지고 변수의 자료형을 추론할 수 있다. 

    → 값을 할당하지 않은 변수는 선언할 수는 없다.

변수 이름을 지을 때 주의할 점
- 숫자로 시작하면 안됨
- 코틀린에서 사용하는 키워드 사용 불가
- 의미있는 단어 사용 권장
- 여러 단어는 카멜 표기법 사용 권장

## 자료형

- 코틀린은 참조형 자료형만 사용

    → 성능 최적화를 위해 컴파일 과정에서 기본형으로 대체 (자동 최적화)

    자료형 형태 구분
    - 기본형 : 순수 자료형 (int, long, float, double 등)
    - 참조형 : 동적 메모리영역에 데이터를 둔다음 이것을 참조하는 자료형 (String, Date 등)

### 정수 자료형

- 부호가 있는 것 (Long, Int, Short, Byte)
- 부호가 없는 것 (ULong, UInt, UShort, UByte)

    → 부호가 있는 형보다 2배 더 많은 양수 표현 가능

    → 코틀린 1.3의 실험 기능이므로 상업 제품 개발에서는 주의

### 실수 자료형

- 실수 저장 자료형 (Double - 기본, Float)

부동 소수점
3.14 * 10^16 = 3.14E + 16 = 2.14E16
- 52비트를 넘어서면 잘리니 오차에 주의!

### 논리 자료형

- 참, 거짓 표현 (Boolean)

### 문자 자료형

- 문자를 표현하기 위해 사용 (Char)
- 작은 따옴표로 감쌈
- 선언은 반드시 문자! / 저장은 문자세트 번호로 저장! / 사용은 숫자 연산 가능!

### 문자열 자료형

- 문자열을 표현 및 추론하기 위해 사용 (String)

문자열에 변수의 값을 사용할 때에는 $를 사용
문자열에 표현식을 사용할 때에는 {} 사용
문자열에 특수문자 사용할 때에는 \, ${} 사용
형식화된 다중 문자열을 표현할 때에는 """ 사용

자료형에 별명을 붙일 때에는 typealias 사용

# **02-3 자료형 검사하고 변환하기**

## null을 허용한 변수 검사

- null 저장 가능한 변수에는 ? 사용
- null을 허용한 변수에 접근하려면 세이프콜이나 non-null 단정 기호 또는 조건문을 사용해야 함

세이프콜(?.) : null이 할당되어 있을 가능성이 있는 변수를 검사하여 안전하게 호출하는 기법
non-null 단정기호 (!!) : 컴파일러의 null 검사는 무시할 수 있으나 실행 시 NPE 발생 가능

- null을 허용한 변수에 안전하게 접근하려면 세이프콜(?.)과 엘비스(?:) 연산자 함께 사용하면 됨

    str1?.length ?: -1    →    if(str1 ≠ null) str1.length else -1

## 자료형 비교 & 검사 & 변환

- 코틀린에서는 기본적으로 자동 형변환이 안되기 때문에 변환 메소드를 사용해야함 (예외 있음)
- 표현식에서는 표현범위가 큰 자료형으로 자동 형변환

== : 값만 비교 
=== : 참조 주소 비교

주의 : 코틀린에서는 참조형으로 선언한 변수의 값이 -128 ~ 127 범위에 있으면 캐시에 그 값을 저장하고 변수는 캐시 주소를 가리킴 

### 스마트 캐스트

- 숫자를 스마트 캐스트 하기 위해서는 자료형으로 Number 사용
- 자료형을 검사할때는 is 키워드 사용, is는 자료형을 검사하고 해당 자료형으로 형 변환
- 스마트 캐스트는 as 키워드 사용, 형 변환이 가능하지 않으면 예외 발생
- null 가능성을 고려한 스마트 캐스트는 as? 키워드 사용
- Any : 코틀린 최상위 기본 클래스 자동 형변환 가능

# **02-4 코틀린 연산자**

### 기본 연산자 (산술, 대입, 증가, 감소, 비교, 논리)

- 산술 연산자 (+, -, *, /, %)
- 대입 연산자 (=, +=, -=, *=, /=, %=)
- 증감 연산자 (++, —)
- 비교 연산자 (>, <, ≥, ≤, ==, ≠, ===, ≠=)
- 논리 연산자 (&&, ||, !)

단축 평가
- 논리곱 연산자(&&)에서 왼쪽 항이 false이면 컴파일러는 오른쪽 항을 실행 안함
- 논리합 연산자(||)에서 왼쪽 항이 true이면 컴파일러는 오른쪽 항을 실행 안함

- 비트 연산자 (shl, shr, ushr, and, or, xor, inv) - 부호비트가 바뀌지 않도로 주의

— 끝! —
