# 08. 제네릭과 배열

# 08-1 제네릭 다루기

## 제네릭 사용의 장점

- 객체의 자료형을 컴파일할 때 체크하기 때문에 객체 자료형의 안정성을 높이고 형 변환의 번거로움이 줄어든다.
- 의도하지 않은 자료형의 객체를 지정하는 것을 막을 수 있다
- 사용할 때 원래의 자료형에서 다른 자료형으로 형 변환 시 발생할 수 있는 오류를 줄여준다.

## 제네릭의 일반적인 사용 방법

- 앵글 브래킷 <> 사이에 형식 매개변수를 넣어서 사용
- 형식 매개변수는 하나 이상 사용 가능
- 형식 매개변수는 기본적으로 null 허용가능 (허용하지 않으려면 <T: Any>로 타입 제한)

### 제네릭 클래스

- 형식 매개변수를 1개 이상 받는 클래스
- 제네릭 클래스 내에 메서드에도 형식 매개변수 사용 가능

    class MyClass<T> {
          fun myMethod(a: T) {
               .......
          }
    }

- 제네릭 클래스 내에 프로퍼티에도 형식 매개변수 사용 가능 (단! 이 경우 자료형이 특정되지 못하므로  클래스 내부에서 사용불가)
- 주 생성자나 부 생성자에서 값을 지정하여 사용

class MyClass<T> {
     var myProp: T
}

### 제네릭 함수  혹은 메서드

- 형식 매개변수를 받는 함수나 메서드
- 함수 앞에 형식 매개변수 지정 (1개 이상)
- 형식 매개변수는 반환 및 매개변수 자료형에 사용 가능

    (용어설명 - p.356) indices : 배열의 유효범위 반환

### 제네릭과 람다식

- 형식 매개변수로 선언된 함수의 매개변수는 자료형을 결정할 수 없기 때문에 연산 시에 오류가 남
- 람다식을 매개변수로 받아서 해결
- 람다식 매개변수를 좀 더 읽기 좋게 하기 위해 typealias 사용

## 자료형 제한하기

- 자바에서는 extends나 super로 자료형 제한
- 코틀린에서는 : 로 자료형 제한 (클래스와 함수 동일)

<클래스의 형식 매개변수 자료형 제한>
class Calc<T: Number> {
     ...
}
<함수의 형식 매개변수 자료형 제한>
fun <T: Number> addLimit(a: T, b: T, op: (T, T) → T): T {
     ...
}
<다수 조건의 형식 매개변수 제한 - 클래스>
class ClassA<T> **where** T: InterfaceA, T: InterfaceB
<다수 조건의 형식 매개변수 제한 - 함수>
fun <T> myMax(a: T, b: T): T **where** T:Number, T:Comparable<T> {
     ...
}

## 상*하위 형식의 가변성

- 가변성 : 형식 매개변수가 클래스 계층에 영향을 주는 것
- 공변성, 반공변성, 무변성 으로 구분

공변성(out) : T'가 T의 하위 자료형이면, C<T'>는 C<T>의 하위 자료형이다.
반공변성(in) : T'가 T의 하위 자료형이면, C<T>는 C<T'>의 하위 자료형이다.
무변성 : C<T>와 C<T'>는 아무 관계가 없다.

### 무변성

- 형식 매개변수에 in이나 out 등으로 공변성이나 반공변성을 지정하지 않은 경우
- 제네릭의 형식 매개변수 인자로 무엇을 넣던지, 생성된 제네릭 객체 간의 자료형은 불일치함

### 공변성

- out 키워드로 공변적임이 선언된 상하 자료형 관계
- 제네릭의 형식 매개변수 인자끼리 상하관계가 성립할 때, 생성된 제네릭 객체끼리도 관계가 성립한다.
- 반환 자료형에만 사용 가능
- 형식 매개변수를 갖는 프로퍼티로 val만 허용
- 만약 var를 사용하려면 private로 지정해야함

### 반공병성

- in 키워드로 반공변적임이 선언된 하상 자료형 관계
- 제네릭의 형식 매개변수 인자끼리 하상관계가 성립할 때, 생성된 제네릭 객체끼리도 관계가 성립한다.
- 메서드의 매개변수로 사용 가능

## 자료형 프로젝션

### 선언 지점 변성

- 클래스를 선언하면서 클래스 자체에 가변성 지정
- 클래스를 사용하는 장소에서는 따로 자료형을 지정할 필요가 없어서 편리

### 사용 지점 변성

- 메서드 매개변수, 제네릭 클래스를 생성하는 등 사용 위치에서 가변성 지정
- 자료형의 안정성 보장

### 스타 프로젝션

- Box<Any?> : 모든 자료형의 요소를 담을 수 있음
- Box<*> : 어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되고 난 후에는 그 자료형과 하위 자료형의 요소만을 담을 수 있음
- in으로 정의되어 있는 형식 매개변수를 *로 받으면 in Nothing으로 간주
- out으로 정의되어 있는 형식 매개변수를 *로 받으면 out Any?인 것으로 간주

Nothing : 최하위 자료형으로 아무것도 가지고 있지 않은 클래스, 아무것도 존재하지 않은 값을 표현할 때 사용

## reified 자료형

- 제네릭 메서드에 reified 형식 매개변수를 지정하면 실행 시간에 접근 가능
- inline 함수에서만 사용 가능

# 08-2 배열 다루기

## 배열을 사용하는 방법

- arryOf(), Array()를 사용하여 배열 생성
- 빈 상태의 배열은 arrayOfNulls()
- 배열의 요소를 for문에서 순환하여 사용하기 위해서는 in 키워드 사용
- 다차원 배열은 1차원 배열을 여러개 만들어서 새로운 배열로 합쳐서 생성
- 자료형을 제한하지 않는 배열에 여러 가지 자료형 혼합하여 생성 가능
- 배열에 자료형을 지정하기 위해서는 arrayOf<자료형 이름<>(), 자료형 이름ArrayOf()
- 배열 요소에 접근하기 위해서는 get(), set(), [] 사용 가능
- 배열 요소를 한꺼번에 출력하기 위해서는 Arrays.toString(배열)
- 다차원 배열을 표시하고자 할 때는 Arrays.deepToString(배열)
- 요소 개수가 많은 배열을 생성하려면 arrayOfNulls이나 표현식 사용

## 배열 제한하고 처리하기

- 배열은 일단 정의되면 배열의 길이와 내용이 메모리에 고정
- 요소를 추가하거나(**plus**) 잘라낼 때에는(**sliceArray**) 새로 할당해야함
- 배열의 자료형을 Any로 만들면 나중에 원하는 자료형으로 초기화 가능

### **맴버 메서드를 통한 배열 순환하기**

- forEach() : 요소 개수만큼 지정한 구문 반복 실행
- forEachIndexed() : 요소 개수만큼 지정한 구문 반복 실행 + 인덱스 출력
- interator를 사용하여 반복 요소 처리 가능

## 배열 정렬하기

- 새로운 배열 반환 : sortedArray(), sortedArrayDescending()
- 원본 배열 정렬 : sort(), sortDescending()
- List 반환 : sorted(), sortedDescending()
- 표현식을 이용한 원본 배열 정렬 : sortBy(), sortByDescending()
- 표현식을 이용해 정렬 후 List 반환 : sortedBy(), sortedBuDescending()
- sortWith()는 Comparator 매개변수를 이용하여 정렬 조건 지정 가능
- 정렬 조건을 인자로 받아서 비교 : compareBy()

## 배열 필터링하기

- filter()
- when()
- minBy(), maxBy()

## 배열 평탄화 하기

- flatten() : 다차원 배열을 단일 배열로 재생성

# 08-3 문자열 다루기

- 문자열은 연속된 문자의 배열
- 문자열은 불변!
- 새로운 값을 할당하려고 한다면 기존 메모리 이외에 새로운 문자열을 위한 메모리를 만들어 할당해야 함
- var로 생성된 문자열은 내부적으로 새로 생성해 할당되고 기존 메모리 공간은 GC에 의해 제거

### 문자열 기능

- 특정 인덱스로 문자열 추출 : substring(), subSequence()
- 문자열 비교 : compareTo()

### StringBuilder 사용하기

- 특정 단어 변경 가능
- 기존 문자열보다 처리 속도가 느리고 그대로 사용하면 임시 메모리 공간 낭비
- 문자열이 자주 변경되는 경우 사용하면 좋음
- append, insert, delete 사용가능

### 기타 문자열 처리

- 소문자/대문자 변경 : toLowerCase(), toUpperCase()
- 특정 문자 단위로 잘라내기 : split()
- 앞뒤 공백 제거 : trim()
- 문자열을 정수로 변환 : toInt()  → NumberFormatException을  try~catch 블록 처리
- 문자열을 정수로 변환하되 숫자가 아닌 문자가 포함되었을 때 null 반환 : toIntOrNull()

## 리터럴 문자열

- \ 를 포함한 escape 문자
- 유니코드 : \u + 코드
- 개행까지 그대로 표시 : """ ~ """
- 특정 문자 기준으로 공백 제거 (기본값은 | ) : trimMargin()
- 형식 문자 : % + 코드
